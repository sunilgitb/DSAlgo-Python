# Python Object Oriented Programming by Joe Marini course example
# Using the postinit function in data classes

from dataclasses import dataclass, field
from typing import List, Optional, ClassVar
from datetime import datetime
import random


@dataclass
class Book:
    title: str
    author: str
    pages: int
    price: float
    
    # TODO: the __post_init__ function lets us customize additional properties
    # after the object has been initialized via built-in __init__
    
    # Fields that will be initialized in __post_init__
    description: str = field(init=False)  # Not in __init__, will be set in __post_init__
    book_id: str = field(init=False)      # Generated ID
    isbn: str = field(default="Unknown")  # Regular field with default
    date_added: datetime = field(default_factory=datetime.now)
    tags: List[str] = field(default_factory=list)
    
    # Computed fields (will be calculated in __post_init__)
    price_per_page: float = field(init=False)
    category: str = field(init=False)
    
    # Class variables
    total_books_created: ClassVar[int] = 0
    
    def __post_init__(self):
        """
        Initialize computed fields and perform setup after the object is created.
        This runs after the automatic __init__ generated by @dataclass.
        """
        # 1. Update class variable to track total books
        Book.total_books_created += 1
        
        # 2. Generate a unique book ID
        author_code = ''.join([name[0].upper() for name in self.author.split()[:2]])
        self.book_id = f"BK{Book.total_books_created:04d}-{author_code}"
        
        # 3. Set the description attribute
        self.description = f"{self.title} by {self.author}, {self.pages} pages - ${self.price:.2f}"
        
        # 4. Compute price per page
        if self.pages > 0:
            self.price_per_page = self.price / self.pages
        else:
            self.price_per_page = 0.0
        
        # 5. Determine category based on page count
        if self.pages < 200:
            self.category = "Short"
        elif self.pages < 500:
            self.category = "Medium"
        else:
            self.category = "Long"
        
        # 6. Auto-generate ISBN if not provided
        if self.isbn == "Unknown":
            self.isbn = f"978-{random.randint(100, 999)}-{random.randint(10, 99)}-{random.randint(1000, 9999)}"
        
        # 7. Add default tags
        self.tags.append(self.category.lower())
        if self.price > 30:
            self.tags.append("premium")
        else:
            self.tags.append("standard")
        
        # 8. Basic validation
        if self.price < 0:
            raise ValueError(f"Price cannot be negative: ${self.price}")
        
        if self.pages <= 0:
            raise ValueError(f"Pages must be positive: {self.pages}")
    
    # Additional methods that use the computed fields
    def apply_discount(self, percent: float):
        """Apply a discount to the book price."""
        if 0 <= percent <= 100:
            self.price = self.price * (1 - percent/100)
            # Update price per page
            if self.pages > 0:
                self.price_per_page = self.price / self.pages
            # Update description
            self.description = f"{self.title} by {self.author}, {self.pages} pages - ${self.price:.2f}"
        return self
    
    def add_tag(self, tag: str):
        """Add a tag to the book."""
        self.tags.append(tag)
        return self
    
    def book_info(self):
        """Return formatted book information."""
        return f"{self.title} (ID: {self.book_id}) - ${self.price:.2f}"
    
    @property
    def is_expensive(self) -> bool:
        """Property to check if book is expensive."""
        return self.price > 35


# Example with inheritance
@dataclass
class EBook(Book):
    file_format: str = "PDF"
    file_size_mb: float = 0.0
    
    def __post_init__(self):
        """Extend parent's __post_init__ for EBook-specific initialization."""
        # Call parent's __post_init__ first
        super().__post_init__()
        
        # EBook specific initialization
        if self.file_size_mb == 0.0:
            # Estimate file size based on pages
            self.file_size_mb = round(self.pages * 0.05, 2)  # ~50KB per page
        
        # Update description for ebooks
        self.description = f"{self.title} by {self.author}, {self.pages} pages [{self.file_format}] - ${self.price:.2f}"
        
        # Add ebook-specific tags
        self.tags.append("digital")
        self.tags.append(self.file_format.lower())


# Driver code
if __name__ == "__main__":
    print("="*80)
    print("DATACLASS __post_init__ METHOD IMPLEMENTATION")
    print("="*80)
    
    print("\n1. CREATING BOOK OBJECTS")
    print("-"*40)
    
    # create some Book objects
    b1 = Book("War and Peace", "Leo Tolstoy", 1225, 39.95)
    b2 = Book("The Catcher in the Rye", "JD Salinger", 234, 29.95)
    b3 = Book("1984", "George Orwell", 328, 19.95)
    
    print("Books created successfully!")
    print(f"Total books created so far: {Book.total_books_created}")
    
    print("\n" + "="*80)
    print("2. ACCESSING __post_init__ GENERATED ATTRIBUTES")
    print("-"*40)
    
    # TODO: use the description attribute
    print("\nBook 1:")
    print(f"  Description: {b1.description}")
    print(f"  Book ID: {b1.book_id}")
    print(f"  ISBN: {b1.isbn}")
    print(f"  Price per page: ${b1.price_per_page:.4f}")
    print(f"  Category: {b1.category}")
    print(f"  Tags: {b1.tags}")
    print(f"  Date added: {b1.date_added.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"  Is expensive? {b1.is_expensive}")
    
    print("\nBook 2:")
    print(f"  Description: {b2.description}")
    print(f"  Book ID: {b2.book_id}")
    print(f"  Price per page: ${b2.price_per_page:.4f}")
    print(f"  Category: {b2.category}")
    print(f"  Tags: {b2.tags}")
    print(f"  Is expensive? {b2.is_expensive}")
    
    print("\n" + "="*80)
    print("3. MODIFYING BOOKS AND UPDATING COMPUTED FIELDS")
    print("-"*40)
    
    print("\nBefore discount:")
    print(f"  {b3.book_info()}")
    print(f"  Price per page: ${b3.price_per_page:.4f}")
    print(f"  Description: {b3.description}")
    
    # Apply discount
    b3.apply_discount(25)  # 25% off
    
    print("\nAfter 25% discount:")
    print(f"  {b3.book_info()}")
    print(f"  Price per page: ${b3.price_per_page:.4f}")
    print(f"  Description: {b3.description}")
    
    # Add tags
    b3.add_tag("dystopian").add_tag("classic")
    print(f"  Tags after adding: {b3.tags}")
    
    print("\n" + "="*80)
    print("4. VALIDATION IN __post_init__")
    print("-"*40)
    
    print("\nTrying to create invalid books:")
    
    # Try to create book with negative price
    print("\na) Negative price:")
    try:
        bad_book1 = Book("Bad Book 1", "Bad Author", 100, -10.0)
        print(f"  Created: {bad_book1.description}")
    except ValueError as e:
        print(f"  ❌ Error: {e}")
    
    # Try to create book with zero pages
    print("\nb) Zero pages:")
    try:
        bad_book2 = Book("Bad Book 2", "Bad Author", 0, 19.99)
        print(f"  Created: {bad_book2.description}")
    except ValueError as e:
        print(f"  ❌ Error: {e}")
    
    print("\n" + "="*80)
    print("5. INHERITANCE EXAMPLE: EBOOK")
    print("-"*40)
    
    # Create an EBook
    ebook = EBook(
        title="Python Programming",
        author="Python Expert",
        pages=450,
        price=34.99,
        file_format="EPUB"
    )
    
    print(f"\nEBook created:")
    print(f"  Description: {ebook.description}")
    print(f"  File format: {ebook.file_format}")
    print(f"  File size: {ebook.file_size_mb} MB")
    print(f"  Tags: {ebook.tags}")
    print(f"  Inherited Book ID: {ebook.book_id}")
    print(f"  Inherited ISBN: {ebook.isbn}")
    
    print("\n" + "="*80)
    print("6. PRACTICAL APPLICATION: BOOKSTORE SYSTEM")
    print("-"*40)
    
    @dataclass
    class InventoryItem:
        book: Book
        quantity: int = 0
        
        # Computed fields
        total_value: float = field(init=False)
        needs_restock: bool = field(init=False)
        item_code: str = field(init=False)
        
        def __post_init__(self):
            """Initialize inventory-specific fields."""
            # Generate item code
            self.item_code = f"INV-{self.book.book_id}-{datetime.now().strftime('%Y%m%d')}"
            
            # Compute total value
            self.total_value = self.book.price * self.quantity
            
            # Determine if restock is needed
            self.needs_restock = self.quantity < 5
            
            # Validation
            if self.quantity < 0:
                raise ValueError(f"Quantity cannot be negative: {self.quantity}")
        
        def sell(self, amount: int = 1):
            """Sell books from inventory."""
            if amount <= self.quantity:
                self.quantity -= amount
                # Update computed fields
                self.total_value = self.book.price * self.quantity
                self.needs_restock = self.quantity < 5
                return True
            return False
        
        def restock(self, amount: int):
            """Restock inventory."""
            self.quantity += amount
            # Update computed fields
            self.total_value = self.book.price * self.quantity
            self.needs_restock = self.quantity < 5
            return self
        
        def __str__(self):
            status = "⚠️ Low Stock" if self.needs_restock else "✅ In Stock"
            return f"{self.book.title}: {self.quantity} units (${self.total_value:.2f}) - {status}"
    
    # Create inventory
    inventory = [
        InventoryItem(b1, quantity=3),
        InventoryItem(b2, quantity=12),
        InventoryItem(b3, quantity=2),
        InventoryItem(ebook, quantity=7)
    ]
    
    print("\nBookstore Inventory:")
    for item in inventory:
        print(f"  {item}")
        print(f"    Item Code: {item.item_code}")
    
    # Simulate sales
    print("\nSimulating sales:")
    if inventory[0].sell(2):
        print(f"  Sold 2 copies of '{inventory[0].book.title}'")
        print(f"  Remaining: {inventory[0].quantity} units")
        print(f"  Needs restock? {inventory[0].needs_restock}")
    
    print("\n" + "="*80)
    print("7. COMPARISON: WITH VS WITHOUT __post_init__")
    print("-"*40)
    
    # Simple dataclass without __post_init__
    @dataclass
    class SimpleBook:
        title: str
        author: str
        pages: int
        price: float
    
    # Complex dataclass with __post_init__
    @dataclass
    class EnhancedBook:
        title: str
        author: str
        pages: int
        price: float
        
        # Additional fields initialized in __post_init__
        description: str = field(init=False)
        book_id: str = field(init=False)
        
        def __post_init__(self):
            self.description = f"{self.title} by {self.author}"
            self.book_id = f"BOOK-{hash(self.title) % 10000:04d}"
    
    print("\nSimple Book (no __post_init__):")
    simple = SimpleBook("Simple", "Author", 100, 9.99)
    print(f"  Created: {simple}")
    print(f"  Has description? {hasattr(simple, 'description')}")
    
    print("\nEnhanced Book (with __post_init__):")
    enhanced = EnhancedBook("Enhanced", "Author", 100, 9.99)
    print(f"  Created: {enhanced}")
    print(f"  Description: {enhanced.description}")
    print(f"  Book ID: {enhanced.book_id}")
    
    print("\n" + "="*80)
    print("8. COMMON __post_init__ PATTERNS")
    print("-"*40)
    
    print("""
    Common Patterns for __post_init__:
    
    1. Computed Fields:
       price_per_page = price / pages
       
    2. Auto-generated IDs:
       book_id = f"BK{count:04d}"
       
    3. Data Validation:
       if price < 0: raise ValueError
       
    4. Default Setup:
       if not tags: tags.append('default')
       
    5. Derived Information:
       category = 'Long' if pages > 500 else 'Short'
       
    6. Formatting:
       description = f"{title} by {author}"
       
    7. Relationship Setup:
       self.inventory = InventoryItem(self)
       
    8. State Initialization:
       self.checked_out = False
    """)
    
    print("\n" + "="*80)
    print("9. BEST PRACTICES")
    print("-"*40)
    
    print("""
    Best Practices for __post_init__:
    
    1. Use field(init=False) for computed fields
    2. Keep __post_init__ focused on initialization
    3. Call super().__post_init__() in inheritance
    4. Validate early and raise exceptions clearly
    5. Document what fields are initialized
    6. Consider performance for expensive operations
    7. Test __post_init__ logic thoroughly
    8. Use for setup only, not business logic
    """)
    
    print("\n" + "="*80)
    print("FINAL DEMONSTRATION")
    print("="*80)
    
    # Create a new book to show all features
    final_book = Book(
        title="The Hobbit",
        author="J.R.R. Tolkien",
        pages=310,
        price=24.95,
        isbn="978-0618260300"  # Providing ISBN, so it won't be auto-generated
    )
    
    print(f"\nFinal Book Demonstration:")
    print(f"  Title: {final_book.title}")
    print(f"  Author: {final_book.author}")
    print(f"  Description: {final_book.description}")
    print(f"  Book ID: {final_book.book_id}")
    print(f"  ISBN (provided): {final_book.isbn}")
    print(f"  Pages: {final_book.pages}")
    print(f"  Category: {final_book.category}")
    print(f"  Price: ${final_book.price:.2f}")
    print(f"  Price per page: ${final_book.price_per_page:.4f}")
    print(f"  Tags: {final_book.tags}")
    print(f"  Date added: {final_book.date_added.strftime('%Y-%m-%d')}")
    print(f"  Total books in system: {Book.total_books_created}")
    
    print("\n" + "="*80)
    print("SUMMARY")
    print("="*80)
    
    print(f"""
    Key Takeaways:
    
    1. __post_init__ runs AFTER the automatic __init__
    2. Use it to initialize computed fields (field(init=False))
    3. Great for validation, auto-generation, and setup
    4. Call super().__post_init__() in inheritance chains
    5. Can modify fields initialized in __init__
    6. Be careful with exceptions in __post_init__
    
    In your implementation:
    • Added __post_init__ method to Book class
    • Created description attribute and other computed fields
    • Demonstrated validation and auto-generation
    • Showed inheritance with EBook class
    • Provided practical examples of usage
    """)